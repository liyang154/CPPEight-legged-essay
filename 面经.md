# 字节

http状态码301  ,下一次访问，post->get

http  keep-alive

hash扩容

hash冲突解决

top(K)

数据量超出哈希表限制（分治法）

算法：

A-1

B-2

C-3

123->‘ABC’，‘LC’，‘AW’

# 腾讯

腾讯云防火墙一面

虚拟化上网带宽，吞吐率，超时时间HZ

http带宽，多线程，AC自动机怎么匹配

最长不重复字符子串[offer48]()

爬楼梯

和为s的数字[offer57]()

链表倒数第k个结点[offer22]()

# 招银网络  提前批 

## 一面0525

### 1、二叉树层次遍历

### 2、查找链表中间结点

### 3、构造函数能否为虚函数

​	不能。

1.虚函数对应一个虚指针，虚指针存储在对象的内存空间。如果构造函数是虚的，就需要通过虚指针执行那个虚函数表（编译期间生成属于类）来调用，可是对象还没有实例化，也就是内存空间还没有，就没有虚函数表，所以构造函数不能是虚函数。

### 4、大小端存储以及如何判断大小端

大端存储： 高位存储在起始位置

小端存储：低位存储在起始位置

网络字节顺序是大端模式。

#### **如何判断一个机器是大端还是小端？**

（1）指针

用指针的办法：把变量的地址强制类型转化成char*,这样就可以每次取出一个字节的内容

```c
#include<stdio.h>
int main()
{
  int a = 1;//这里为了方便，以1为例
  char*p = (char*)(&a);
  if (*p == 1)
  {
	 printf("little endian\n");//小端存储
  }
  else
  {
	 printf("big endian\n");//大端存储
  }
  return 0;
} 
```

（2）联合体

联合体中定义一个char 类型的变量和int类型的变量，利用二者所占同一段存储空间，可以通过引用联合体变量中的成员访问char 类型的数据。取出一个字节的内容

```c++
#include<stdio.h>
union endian
{
   char c;
   int i;
}en;
 
int main()
{
   en.i = 1;
   if (en.c == 1)
   {
	 printf("little endian\n");
   }
   else
   {
	 printf("big endian\n");
   }
   return 0;
}
```

### 5、结构体/类字节对齐

static不占用结构体/类大小。

#### 类

（1）空类

空类也会被实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。

（2）含有static变量

```c++
class CBase 
{ 
	int a; 
	char p; 
}; 
```

sizeof(CBase)=8;

记得对齐的问题。int 占4字节//注意这点和struct的对齐原则很像！！！！！
char占一字节，补齐3字节

（3）含有虚函数和函数

```c++
class CBase 
{ 
public: 
	CBase(void); 
	virtual ~CBase(void); 
private: 
	int  a; 
	char *p; 
};
```

sizeof(CBase)=12；

C++ 类中有虚函数的时候有一个指向虚函数的指针（vptr），在32位系统分配指针大小为4字节。无论多少个虚函数，只有这一个指针，4字节。//注意一般的函数是没有这个指针的，而且也不占类的内存。

（4）子类

```c++
class CChild : public CBase 
{ 
public: 
	CChild(void); 
	~CChild(void); 

	virtual void test();
private: 
	int b; 
}; 
```

sizeof(CChild)=16

可见子类的大小是本身成员变量的大小加上父类的大小。//其中有一部分是虚拟函数表的原因，一定要知道父类子类共享一个虚函数指针。

（5）总结

空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

（一）类内部的成员变量：

- 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
- static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。

（二）类内部的成员函数：

- 普通函数：不占用内存。
- 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的

### 6、什么是野指针，举个例子

指向被释放内存的对象或者没有访问权限的内存的指针。

野指针产生的原因：

​	（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。

​    （2）指针p被free或者delete之后，没有置为NULL。

​	（3）指针操作超越了变量的作用范围。

```c++
class A 
{ 
 public:
	void Func(void){ cout << “Func of class A” << endl; }
};

void Test(void)
{
     A  *p;
     if(...)
     {
        A  a;
        p = &a; // 注意 a 的生命期
     }
     p->Func(); // p是“野指针”
}
```

### 7，什么是内存泄漏、举个例子

内存泄露是指：内存泄漏也称作"存储渗漏"，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。(其实说白了就是该内存空间使用完毕之后未回收)即所谓内存泄漏。

内存泄漏的检测：valgrind --leak-check=full ./a.out

解决方式：重载new和delete运算符

思路：重载的new运算符（返回值为void *,重载函数调用malloc）和delete运算符(返回值为void,重载函数调用free)，为了判断申请的内存是否最后被释放，我们需要创建一个链表，当前申请一块内存的时候加入到链表中，释放一块空间的时候，从链表中删除和释放内存首地址相同的结点就可以，最后理想的情况为链表为空，如果不为空，那就说明发生了内存泄漏。

### 8、什么是指针函数和函数指针

#### 指针函数和函数指针

**指针函数**：就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。

写法：

```c
int *fun(int x,int y);
```

**函数指针**：其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。

声明格式：类型说明符 (*函数名) (参数)

```c
int (*fun)(int x,int y);
```

函数指针是需要把一个函数的地址赋值给它，有两种写法：



### 9、动静态库含义、区别、用法

### 10、memcpy和strcpy，能否实现一下memcpy

### 11、声明子类，构造函数和析构函数的执行顺序

### 12、查找数组中第二大的数

### 13、简单介绍一下项目，然后也没问关于项目的东西。

## 二面0607

### 1、默认的析构函数是虚函数吗?为什么？

### 2、析构函数什么时候设置成虚函数？为什么？

### 3、struct和union的区别

### 4、stl容器都用过哪些

### 5、说一下这些容器的底层的数据结构

### 6、说一下vector的扩容机制

### 7、用过哪些数据库？说一下数据库的隔离机制和这些隔离机制解决的问题。

### 8、说一下MySQL的引擎，重点说一下它们之间的区别？

### 9、说一下索引

### 10、说一下B+树和B树之间的区别

### 11、讲一下IO多路复用的机制

### 12、说一下epoll的两种工作模式

### 13、说一下http和https之间的区别

### 14、了解设计模式吗？

# 博乐科技提前批

## 一面 0611

1、介绍一下面向对象

2、面向对象的特征

3、常用的数据结构介绍几个

4、链表的好处

5、常用的算法介绍几个

6、二分查找算法的前提是什么？

7、链表可以进行二分查找吗

8、介绍一下排序算法

9、重温了一遍笔试题

10、手撕代码：有一个数组，数组元素乱序，将数组元素存入二叉树中，保证在输出二叉树的时候，输出结果是有序的。注意：不能使用排序库函数，数组中的每个元素只能访问一次。

11、数学问题：在一个9*9的棋盘上，放置9个棋子，保证每一行每一列只能有1个棋子，问有多少种放置情况。不需要写代码，只用给出结果和计算过程。

手撕代码没写出来。排序算法掌握的不牢固。常见的数据结构需要多记几个。

